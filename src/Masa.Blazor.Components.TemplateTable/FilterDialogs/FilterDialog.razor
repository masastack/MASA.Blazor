@namespace Masa.Blazor.Components.TemplateTable.FilterDialogs

<PModal @bind-Value="dialog"
        Width="640"
        Title="Filters"
        Persistent
        OnSave="HandleOnSave">

    @if (_filters.Count == 0)
    {
        <p class="grey--text">No filters applied</p>
    }

    @for (int i = 0; i < _filters.Count; i++)
    {
        var index = i;
        var filter = _filters[index];

        <div class="d-flex align-center mb-2">
            <div style="width: 86px; max-width: 86px;"
                 class="mr-2 text-right">
                @if (index == 0)
                {
                    <span>When</span>
                }
                else if (index == 1)
                {
                    <MSelect @bind-Value="@_operator"
                             Items="@Operators"
                             ItemText="u => u"
                             ItemValue="u => u"
                             Class="filter-operator"
                             Dense
                             Outlined
                             HideDetails="@true">
                    </MSelect>
                }
                else
                {
                    <span>@_operator</span>
                }
            </div>

            <MSelect @bind-Value="@filter.ColumnId"
                     Items="_computedColumns"
                     ItemText="u => u.Name"
                     ItemValue="u => u.Id"
                     Label="Field"
                     TItem="ColumnInfo"
                     TItemValue="string"
                     TValue="string"
                     Class="mr-2"
                     Style="max-width: 150px"
                     Dense
                     Filled
                     HideDetails="@true"
                     OnSelect="@filter.OnSelect">
            </MSelect>
            <MSelect @bind-Value="@filter.Func"
                     Items="@filter.FuncList"
                     ItemText="u => u"
                     ItemValue="u => u"
                     Label="Func"
                     Class="mr-2"
                     Style="max-width: 150px"
                     Dense
                     Filled
                     HideDetails="@true">
            </MSelect>
            @if ((filter.Func is FilterTypes.SelectFilterEqual or FilterTypes.SelectFilterNotEqual) && filter.SelectOptions is not null)
            {
                <MSelect @bind-Value="@filter.Expected"
                         Items="@filter.SelectOptions"
                         ItemText="u => u.Label"
                         ItemValue="u => u.Value"
                         Label="Expected"
                         Class="mr-2"
                         Style="max-width: 150px"
                         Dense
                         Filled
                         HideDetails="@true">
                </MSelect>
            }
            else if ((filter.Func is FilterTypes.MultiSelectContainsOne or FilterTypes.MultiSelectNotContains) && filter.SelectOptions is not null)
            {
                <MSelect @bind-Value="@filter.MultiSelect"
                         TItem="SelectOption"
                         TItemValue="string"
                         TValue="List<string>"
                         Items="@filter.SelectOptions"
                         ItemText="u => u.Label"
                         ItemValue="u => u.Value"
                         Label="Expected"
                         Class="mr-2"
                         Style="max-width: 150px"
                         Multiple
                         Dense
                         Filled
                         HideDetails="@true"
                         OnSelect="_ => OnMultiSelect(filter)">
                </MSelect>
            }
            else if (!_noExpectedFuncs.Contains(filter.Func))
            {
                <MTextField @bind-Value="@filter.Expected"
                            Label="Expected"
                            Class="mr-2"
                            Style="max-width: 150px"
                            Filled
                            Dense
                            HideDetails="@true">
                </MTextField>
            }
            <MSpacer/>
            <MButton IconName="mdi-close"
                     OnClick="@(() => RemoveFilter(filter))">
            </MButton>
        </div>
    }

    <MButton Text
             LeftIconName="mdi-plus"
             Color="primary"
             OnClick="@AddNewFilter">
        Add filter
    </MButton>
</PModal>

@code {

    [Parameter] public IList<ColumnInfo> Columns { get; set; } = [];

    /// <summary>
    /// Use this to filter out hidden columns when selecting columns.
    /// </summary>
    [Parameter] public HashSet<string> HiddenColumnIds { get; set; } = [];

    [Parameter] public View? ActiveView { get; set; }

    [Parameter] public EventCallback<Filter> OnSave { get; set; }

    private static readonly IList<string> Operators = ["and", "or"];

    private static readonly HashSet<string> _noExpectedFuncs =
    [
        FilterTypes.Empty,
        FilterTypes.NotEmpty,
        FilterTypes.MultiSelectEmpty,
        FilterTypes.MultiSelectNotEmpty,
        ..FilterTypes.SupportedBooleanFilters
    ];

    private HashSet<string> _prevHiddenColumnIds = [];
    private Guid _prevActiveViewId;

    private IList<ColumnInfo> _computedColumns = [];

    /// <summary>
    /// accepted values: "and", "or"
    /// </summary>
    private string _operator = "and";

    protected override void OnParametersSet()
    {
        base.OnParametersSet();

        if (ActiveView is not null && (_prevActiveViewId != ActiveView.Id || !_prevHiddenColumnIds.SetEquals(HiddenColumnIds)))
        {
            _prevActiveViewId = ActiveView.Id;
            _prevHiddenColumnIds = HiddenColumnIds;
            _computedColumns = Columns.Where(u => !HiddenColumnIds.Contains(u.Id)).Where(u => u.Type != ColumnType.Actions).ToList();

            if (ActiveView.Filter is not null)
            {
                _filters.Clear();
                foreach (var option in ActiveView.Filter.Options)
                {
                    var column = Columns.FirstOrDefault(u => u.Id == option.ColumnId);
                    if (column is null)
                    {
                        continue;
                    }

                    var filterOption = new FilterModel(column)
                    {
                        Func = option.Func,
                        Expected = option.Expected
                    };

                    StandardToLogical(filterOption);
                    _filters.Add(filterOption);
                }

                _operator = ActiveView.Filter.Operator == FilterOperator.And ? "and" : "or";
            }
        }
    }

    private bool dialog;

    private List<FilterModel> _filters = [];

    internal void Open()
    {
        dialog = true;
        StateHasChanged();
    }

    private void AddNewFilter()
    {
        if (Columns.Count == 0)
        {
            return;
        }

        var filter = new FilterModel(Columns.First());
        _filters.Add(filter);
    }

    private void RemoveFilter(FilterModel filterModel)
    {
        _filters.Remove(filterModel);
    }

    private void OnMultiSelect(FilterModel filter)
    {
        filter.Expected = "{ in: [" + string.Join(", ", filter.MultiSelect.Select(u => $"\"{u}\"")) + "]}";
    }

    private void HandleOnSave()
    {
        dialog = false;

        var request = new Filter
        {
            Options = _filters.Select(u =>
            {
                var item = u.ToFilterOption();
                LogicalToStandard(item);
                return item;
            }).ToList(),
            Operator = _operator == "and" ? FilterOperator.And : FilterOperator.Or
        };

        OnSave.InvokeAsync(request);
    }

    private void LogicalToStandard(FilterOption option)
    {
        if (FilterTypes.SupportedBooleanFilters.Contains(option.Func))
        {
            var isEq = option.Func == FilterTypes.BooleanFilterEqualTrue;
            option.Func = "eq";
            option.Expected = isEq ? "true" : "false";
        }
        else if (FilterTypes.SupportedSelectFilters.Contains(option.Func))
        {
            switch (option.Func)
            {
                case FilterTypes.SelectFilterEqual:
                    option.Func = "eq";
                    break;
                case FilterTypes.SelectFilterNotEqual:
                    option.Func = "neq";
                    break;
                case FilterTypes.Empty:
                    option.Func = "eq";
                    option.Expected = string.Empty;
                    break;
                case FilterTypes.NotEmpty:
                    option.Func = "neq";
                    option.Expected = string.Empty;
                    break;
            }
        }
        else if (FilterTypes.EmptyFilters.Contains(option.Func))
        {
            switch (option.Func)
            {
                case FilterTypes.Empty:
                    option.Func = "eq";
                    option.Expected = string.Empty;
                    break;
                case FilterTypes.NotEmpty:
                    option.Func = "neq";
                    option.Expected = string.Empty;
                    break;
                default:
                    throw new NotSupportedException($"Unsupported filter func: {option.Func}");
            }
        }
        else if (FilterTypes.SupportedMultiSelectFilters.Contains(option.Func))
        {
            if (option.Func is FilterTypes.MultiSelectContainsOne)
            {
                option.Func = "some";
                option.Type = ExpectedType.Expression;

                if (string.IsNullOrWhiteSpace(option.Expected))
                {
                    option.Expected = "{ in: [] }";
                }
            }
            else if (option.Func is FilterTypes.MultiSelectNotContains)
            {
                option.Func = "none";
                option.Type = ExpectedType.Expression;

                if (string.IsNullOrWhiteSpace(option.Expected))
                {
                    option.Expected = "{ in: [] }";
                }
            }
            else if (option.Func is FilterTypes.MultiSelectEmpty)
            {
                option.Func = "any";
                option.Expected = "false";
                option.Type = ExpectedType.Boolean;
            }
            else if (option.Func is FilterTypes.MultiSelectNotEmpty)
            {
                option.Func = "any";
                option.Expected = "true";
                option.Type = ExpectedType.Boolean;
            }
        }
    }

    private void StandardToLogical(FilterModel option)
    {
        if (option.Column.Type == ColumnType.Checkbox)
        {
            option.Func = option.Expected == "true" ? FilterTypes.BooleanFilterEqualTrue : FilterTypes.BooleanFilterEqualFalse;
        }
        else if (option.Column.Type == ColumnType.Select)
        {
            option.Func = option.Func switch
            {
                "eq" => option.Expected == string.Empty ? FilterTypes.Empty : FilterTypes.SelectFilterEqual,
                "neq" => option.Expected == string.Empty ? FilterTypes.NotEmpty : FilterTypes.SelectFilterNotEqual,
                _ => option.Func
            };
        }
        else if (option.Column.Type == ColumnType.Image)
        {
            option.Func = option.Func switch
            {
                "eq" => FilterTypes.Empty,
                "neq" => FilterTypes.NotEmpty,
                _ => throw new NotSupportedException($"Unsupported filter func: {option.Func}")
            };
        }
        else if (option.Column.Type == ColumnType.MultiSelect)
        {
            Console.Out.WriteLine("option.Expected: " + option.Expected);
            if (option.Func == "any")
            {
                option.Func = option.Expected == "true" ? FilterTypes.MultiSelectNotEmpty : FilterTypes.MultiSelectEmpty;
            }
            else
            {
                if (option.Func == "some")
                {
                    option.Func = FilterTypes.MultiSelectContainsOne;
                }
                else if (option.Func == "none")
                {
                    option.Func = FilterTypes.MultiSelectNotContains;
                }

                if (option.Expected == "{ in: [] }")
                {
                    option.Expected = string.Empty;
                }

                var firstQuote = option.Expected.IndexOf('"');
                var lastQuote = option.Expected.LastIndexOf('"');

                if (firstQuote != -1 && lastQuote != -1)
                {
                    var values = option.Expected.Substring(firstQuote + 1, lastQuote - firstQuote - 1).Split(", ");
                    Console.Out.WriteLine("values: " + string.Join(", ", values));
                    option.MultiSelect = values.ToList();
                }
            }
        }
    }

}