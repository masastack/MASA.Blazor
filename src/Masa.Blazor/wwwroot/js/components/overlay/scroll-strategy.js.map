{"version":3,"file":"scroll-strategy.js","sources":["../../../../../Masa.Blazor.JS/src/utils/getScrollParent.ts","../../../../../Masa.Blazor.JS/src/components/overlay/scroll-strategy.ts"],"sourcesContent":["export function getScrollParent (el?: HTMLElement) {\r\n  while (el) {\r\n    if (hasScrollbar(el)) return el\r\n    el = el.parentElement!\r\n  }\r\n\r\n  return document.scrollingElement as HTMLElement\r\n}\r\n\r\nexport function getScrollParents (el?: Element | null, stopAt?: Element | null) {\r\n  const elements: HTMLElement[] = []\r\n\r\n  if (stopAt && el && !stopAt.contains(el)) return elements\r\n\r\n  while (el) {\r\n    if (hasScrollbar(el)) elements.push(el as HTMLElement)\r\n    if (el === stopAt) break\r\n    el = el.parentElement!\r\n  }\r\n\r\n  return elements\r\n}\r\n\r\nexport function hasScrollbar (el?: Element | null) {\r\n  if (!el || el.nodeType !== Node.ELEMENT_NODE) return false\r\n\r\n  const style = window.getComputedStyle(el)\r\n  return style.overflowY === 'scroll' || (style.overflowY === 'auto' && el.scrollHeight > el.clientHeight)\r\n}\r\n","import { getScrollParents, hasScrollbar } from \"utils/getScrollParent\";\r\nimport { convertToUnit } from \"utils/helper\";\r\n\r\ntype StrategyProps = {\r\n  strategy: \"none\" | \"block\" | \"close\" | \"reposition\";\r\n  contained: boolean | undefined;\r\n};\r\n\r\ntype ScrollStrategyData = {\r\n  root: HTMLElement | undefined;\r\n  contentEl: HTMLElement | undefined;\r\n  targetEl: HTMLElement | undefined;\r\n  invoker?: DotNet.DotNetObject;\r\n};\r\n\r\ntype ScrollStrategyResult = {\r\n  bind?: () => void;\r\n  unbind: () => void;\r\n};\r\n\r\nexport function useScrollStrategies(\r\n  props: StrategyProps,\r\n  root: HTMLElement | undefined,\r\n  contentEl: HTMLElement | undefined,\r\n  targetEl: HTMLElement | undefined,\r\n  dotNet?: DotNet.DotNetObject\r\n): ScrollStrategyResult {\r\n  if (props.strategy === \"block\") {\r\n    return useBlockScrollStrategy(\r\n      {\r\n        root,\r\n        contentEl,\r\n        targetEl,\r\n      },\r\n      props\r\n    );\r\n  } else {\r\n    return useInvokerScrollStrategy(\r\n      {\r\n        root,\r\n        contentEl,\r\n        targetEl,\r\n        invoker: dotNet,\r\n      },\r\n      props\r\n    );\r\n  }\r\n}\r\n\r\nfunction useBlockScrollStrategy(\r\n  data: ScrollStrategyData,\r\n  options: StrategyProps\r\n): ScrollStrategyResult {\r\n  const offsetParent = data.root.offsetParent;\r\n  const scrollElements = [\r\n    ...new Set([\r\n      ...getScrollParents(\r\n        data.contentEl,\r\n        options.contained ? offsetParent : undefined\r\n      ),\r\n    ]),\r\n  ];\r\n\r\n  const scrollableParent = ((el) => hasScrollbar(el) && el)(\r\n    offsetParent || document.documentElement\r\n  );\r\n\r\n  const bind = () => {\r\n    if (scrollableParent) {\r\n      data.root.classList.add(\"m-overlay--scroll-blocked\");\r\n    }\r\n\r\n    const scrollbarWidth =\r\n      window.innerWidth - document.documentElement.offsetWidth;\r\n\r\n    scrollElements\r\n      .filter((el) => !el.classList.contains(\"m-overlay-scroll-blocked\"))\r\n      .forEach((el, i) => {\r\n        el.style.setProperty(\r\n          \"--m-body-scroll-x\",\r\n          convertToUnit(-el.scrollLeft)\r\n        );\r\n        el.style.setProperty(\"--m-body-scroll-y\", convertToUnit(-el.scrollTop));\r\n\r\n        if (el !== document.documentElement) {\r\n          el.style.setProperty(\r\n            \"--m-scrollbar-offset\",\r\n            convertToUnit(scrollbarWidth)\r\n          );\r\n        }\r\n\r\n        el.classList.add(\"m-overlay-scroll-blocked\");\r\n      });\r\n  };\r\n\r\n  bind();\r\n\r\n  return {\r\n    bind,\r\n    unbind: () => {\r\n      scrollElements\r\n        .filter((el) => el.classList.contains(\"m-overlay-scroll-blocked\"))\r\n        .forEach((el, i) => {\r\n          const x = parseFloat(el.style.getPropertyValue(\"--m-body-scroll-x\"));\r\n          const y = parseFloat(el.style.getPropertyValue(\"--m-body-scroll-y\"));\r\n\r\n          const scrollBehavior = el.style.scrollBehavior;\r\n\r\n          el.style.scrollBehavior = \"auto\";\r\n          el.style.removeProperty(\"--m-body-scroll-x\");\r\n          el.style.removeProperty(\"--m-body-scroll-y\");\r\n          el.style.removeProperty(\"--m-scrollbar-offset\");\r\n          el.classList.remove(\"m-overlay-scroll-blocked\");\r\n\r\n          el.scrollLeft = -x;\r\n          el.scrollTop = -y;\r\n\r\n          el.style.scrollBehavior = scrollBehavior;\r\n        });\r\n\r\n      if (scrollableParent) {\r\n        data.root.classList.remove(\"m-overlay--scroll-blocked\");\r\n      }\r\n    },\r\n  };\r\n}\r\n\r\nfunction useInvokerScrollStrategy(\r\n  data: ScrollStrategyData,\r\n  options: StrategyProps\r\n) {\r\n  const el = data.targetEl ?? data.contentEl;\r\n\r\n  const onScroll = () => {\r\n    data.invoker?.invokeMethodAsync(\r\n      \"ScrollStrategy_OnScroll\",\r\n      options.strategy\r\n    );\r\n  };\r\n\r\n  const scrollElements = [document, ...getScrollParents(el)];\r\n  scrollElements.forEach((el) =>\r\n    el.addEventListener(\"scroll\", onScroll, { passive: true })\r\n  );\r\n\r\n  return {\r\n    unbind: () => {\r\n      data.invoker?.dispose();\r\n      scrollElements.forEach((el) =>\r\n        el.removeEventListener(\"scroll\", onScroll)\r\n      );\r\n    },\r\n  };\r\n}\r\n"],"names":["getScrollParents","el","stopAt","elements","contains","hasScrollbar","push","parentElement","nodeType","Node","ELEMENT_NODE","style","window","getComputedStyle","overflowY","scrollHeight","clientHeight","useScrollStrategies","props","root","contentEl","targetEl","dotNet","strategy","data","options","offsetParent","scrollElements","Set","contained","undefined","scrollableParent","document","documentElement","bind","classList","add","scrollbarWidth","innerWidth","offsetWidth","filter","forEach","i","setProperty","convertToUnit","scrollLeft","scrollTop","unbind","x","parseFloat","getPropertyValue","y","scrollBehavior","removeProperty","remove","useBlockScrollStrategy","_a","onScroll","invoker","invokeMethodAsync","addEventListener","passive","dispose","removeEventListener","useInvokerScrollStrategy"],"mappings":"2CASgB,SAAAA,EAAkBC,EAAqBC,GACrD,MAAMC,EAA0B,GAEhC,GAAID,GAAUD,IAAOC,EAAOE,SAASH,GAAK,OAAOE,EAEjD,KAAOF,IACDI,EAAaJ,IAAKE,EAASG,KAAKL,GAChCA,IAAOC,IACXD,EAAKA,EAAGM,cAGV,OAAOJ,CACT,CAEM,SAAUE,EAAcJ,GAC5B,IAAKA,GAAMA,EAAGO,WAAaC,KAAKC,aAAc,OAAO,EAErD,MAAMC,EAAQC,OAAOC,iBAAiBZ,GACtC,MAA2B,WAApBU,EAAMG,WAA+C,SAApBH,EAAMG,WAAwBb,EAAGc,aAAed,EAAGe,YAC7F,CCRM,SAAUC,EACdC,EACAC,EACAC,EACAC,EACAC,GAEA,MAAuB,UAAnBJ,EAAMK,SAsBZ,SACEC,EACAC,GAEA,MAAMC,EAAeF,EAAKL,KAAKO,aACzBC,EAAiB,IAClB,IAAIC,IAAI,IACN5B,EACDwB,EAAKJ,UACLK,EAAQI,UAAYH,OAAeI,MAKnCC,GAAqB9B,EACzByB,GAAgBM,SAASC,gBADO5B,EAAaJ,IAAOA,GAIhDiC,EAAO,KACPH,GACFP,EAAKL,KAAKgB,UAAUC,IAAI,6BAG1B,MAAMC,EACJzB,OAAO0B,WAAaN,SAASC,gBAAgBM,YAE/CZ,EACGa,QAAQvC,IAAQA,EAAGkC,UAAU/B,SAAS,8BACtCqC,SAAQ,CAACxC,EAAIyC,KACZzC,EAAGU,MAAMgC,YACP,oBACAC,GAAe3C,EAAG4C,aAEpB5C,EAAGU,MAAMgC,YAAY,oBAAqBC,GAAe3C,EAAG6C,YAExD7C,IAAO+B,SAASC,iBAClBhC,EAAGU,MAAMgC,YACP,uBACAC,EAAcP,IAIlBpC,EAAGkC,UAAUC,IAAI,2BAA2B,GAC5C,EA7BmB,IAAEnC,EAkC3B,OAFAiC,IAEO,CACLA,OACAa,OAAQ,KACNpB,EACGa,QAAQvC,GAAOA,EAAGkC,UAAU/B,SAAS,8BACrCqC,SAAQ,CAACxC,EAAIyC,KACZ,MAAMM,EAAIC,WAAWhD,EAAGU,MAAMuC,iBAAiB,sBACzCC,EAAIF,WAAWhD,EAAGU,MAAMuC,iBAAiB,sBAEzCE,EAAiBnD,EAAGU,MAAMyC,eAEhCnD,EAAGU,MAAMyC,eAAiB,OAC1BnD,EAAGU,MAAM0C,eAAe,qBACxBpD,EAAGU,MAAM0C,eAAe,qBACxBpD,EAAGU,MAAM0C,eAAe,wBACxBpD,EAAGkC,UAAUmB,OAAO,4BAEpBrD,EAAG4C,YAAcG,EACjB/C,EAAG6C,WAAaK,EAEhBlD,EAAGU,MAAMyC,eAAiBA,CAAc,IAGxCrB,GACFP,EAAKL,KAAKgB,UAAUmB,OAAO,4BAC5B,EAGP,CAjGWC,CACL,CACEpC,OACAC,YACAC,YAEFH,GA6FN,SACEM,EACAC,SAEA,MAAMxB,EAAsB,QAAjBuD,EAAAhC,EAAKH,gBAAY,IAAAmC,EAAAA,EAAAhC,EAAKJ,UAE3BqC,EAAW,WACH,QAAZD,EAAAhC,EAAKkC,eAAO,IAAAF,GAAAA,EAAEG,kBACZ,0BACAlC,EAAQF,SACT,EAGGI,EAAiB,CAACK,YAAahC,EAAiBC,IAKtD,OAJA0B,EAAec,SAASxC,GACtBA,EAAG2D,iBAAiB,SAAUH,EAAU,CAAEI,SAAS,MAG9C,CACLd,OAAQ,WACQ,QAAdS,EAAAhC,EAAKkC,eAAS,IAAAF,GAAAA,EAAAM,UACdnC,EAAec,SAASxC,GACtBA,EAAG8D,oBAAoB,SAAUN,IAClC,EAGP,CApHWO,CACL,CACE7C,OACAC,YACAC,WACAqC,QAASpC,GAEXJ,EAGN"}