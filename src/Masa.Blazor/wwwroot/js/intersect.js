function e(e,n,o,t){return new(o||(o=Promise))((function(r,c){function i(e){try{l(t.next(e))}catch(e){c(e)}}function s(e){try{l(t.throw(e))}catch(e){c(e)}}function l(e){var n;e.done?r(e.value):(n=e.value,n instanceof o?n:new o((function(e){e(n)}))).then(i,s)}l((t=t.apply(e,n||[])).next())}))}function n(n,t,r){var c;if(!t)throw new Error("the handle cannot be null");const i=null!==(c=null==r?void 0:r.once)&&void 0!==c&&c,s=function(e){if(!e)return null;return{rootMargin:e.rootMargin,root:e.rootSelector?document.querySelector(e.rootSelector):null,threshold:e.threshold}}(r),l=new IntersectionObserver(((r=[],c)=>e(this,void 0,void 0,(function*(){const e=r.some((e=>e.isIntersecting));i&&!e||(yield t.invokeMethodAsync("Invoke",{isIntersecting:e})),e&&i&&o(n)}))),s);n._observe=Object(n._observe),n._observe={handle:t,observer:l},l.observe(n)}function o(e){const n=e._observe;n&&(n.observer.unobserve(e),n.handle.dispose(),delete e._observe)}export{n as observe,o as unobserve};
//# sourceMappingURL=intersect.js.map
