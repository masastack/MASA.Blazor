@namespace Masa.Blazor.Presets
@using Microsoft.AspNetCore.Components.Routing
@using Masa.Blazor.Presets.PageContainer
@inherits PatternPathComponentBase

<PPageContainer IncludePatterns="TabbedPatterns"
                SelfPatterns="SelfPatterns"
                OnlyRenderIncluded>
    @ChildContent
</PPageContainer>

@foreach (var path in _stackPatternPaths.OrderBy(u => u.CreatedAt))
{
    <MDialog Transition="dialog-right-transition"
             Value="@path.Active"
             Fullscreen
             @key="path.Pattern">
        <PPageContainerItem Value="@(path.Pattern == GetCurrentPatternPath().Pattern)">
            <MButton Icon OnClick="@HandleOnPrevious">
                <MIcon>$goBack</MIcon>
            </MButton>
            @ChildContent
        </PPageContainerItem>
    </MDialog>
}

@code {

    enum PageType
    {
        Tab,
        Stack
    }

    [Parameter] public RenderFragment? ChildContent { get; set; }

    [Parameter] [EditorRequired] public IEnumerable<string> TabbedPatterns { get; set; } = Array.Empty<string>();

    private readonly Stack<StackPatternPath> _stackPatternPaths = new();

    private bool _locationChangedByUserClick;

    private string? _previousPath;
    private PageType _pageTypeOfPreviousPath;

    private string? _latestTabPath;

    private HashSet<string> _prevTabbedPatterns = new();
    private HashSet<Regex> _cachedTabbedPatterns = new();

    protected override void OnInitialized()
    {
        base.OnInitialized();

        UpdateRegexes();

        var patternPath = GetCurrentStackPatternPath();
        if (!IsTabbedPattern(patternPath.AbsolutePath))
        {
            _stackPatternPaths.Push(patternPath);
        }
        else
        {
            _latestTabPath = patternPath.AbsolutePath;
        }

        _previousPath = patternPath.AbsolutePath;

        NavigationManager.LocationChanged += NavigationManagerOnLocationChanged;
    }

    protected override void OnParametersSet()
    {
        base.OnParametersSet();

        UpdateRegexes();
    }

    private void UpdateRegexes()
    {
        if (_prevTabbedPatterns.SetEquals(TabbedPatterns)) return;

        _prevTabbedPatterns = new HashSet<string>(TabbedPatterns);
        _cachedTabbedPatterns = TabbedPatterns
            .Select(p => new Regex(p, RegexOptions.IgnoreCase)).ToHashSet();
    }

    private bool IsTabbedPattern(string absolutePath)
    {
        return _cachedTabbedPatterns.Any(r => r.IsMatch(absolutePath));
    }

    private void NavigationManagerOnLocationChanged(object? sender, LocationChangedEventArgs e)
    {
        if (_locationChangedByUserClick)
        {
            _locationChangedByUserClick = false;
            return;
        }

        var currentPath = NavigationManager.GetAbsolutePath();
        var existInStack = _stackPatternPaths.Any(p => p.AbsolutePath == currentPath);
        var isTabbedPath = IsTabbedPattern(currentPath);

        // 1. 导航到新的stack页面，直接push
        // 2. 导航到tab页面，更新_latestTabPath
        // 3. 导航到已经存在的stack页面，不做任何操作

        if (isTabbedPath)
        {
            if (_pageTypeOfPreviousPath == PageType.Tab)
            {
                _latestTabPath = currentPath;
                return;
            }

            if (_pageTypeOfPreviousPath == PageType.Stack)
            {
                CloseTopPageOfStack();
                _previousPath = currentPath;
                _pageTypeOfPreviousPath = isTabbedPath ? PageType.Tab : PageType.Stack;
                InvokeAsync(StateHasChanged);
                return;
            }
        }
        else
        {
            if (existInStack && _pageTypeOfPreviousPath == PageType.Stack)
            {
                CloseTopPageOfStack();
                _previousPath = currentPath;
                _pageTypeOfPreviousPath = isTabbedPath ? PageType.Tab : PageType.Stack;
                InvokeAsync(StateHasChanged);
                return;
            }
        }


        _previousPath = currentPath;
        _pageTypeOfPreviousPath = isTabbedPath ? PageType.Tab : PageType.Stack;

        var currentPatternPath = GetCurrentStackPatternPath();
        if (currentPatternPath.IsSelf)
        {
            var renderedPatternPath = _stackPatternPaths.FirstOrDefault(p => p.Pattern == currentPatternPath.Pattern);
            if (renderedPatternPath is not null)
            {
                renderedPatternPath.UpdatePath(NavigationManager.GetAbsolutePath());
                InvokeAsync(StateHasChanged);
            }
        }

        if (_stackPatternPaths.Any(p => p.Pattern == currentPatternPath.Pattern))
        {
            return;
        }

        _stackPatternPaths.Push(currentPatternPath);

        InvokeAsync(StateHasChanged);
    }

    private void HandleOnPrevious()
    {
        _locationChangedByUserClick = true;

        // var uriNavigateTo = _stackPatternPaths.Count > 1 ? _stackPatternPaths.ElementAt(1).AbsolutePath : _latestTabPath ?? "/";
        // NavigationManager.Replace(uriNavigateTo);

        Js.InvokeVoidAsync(JsInteropConstants.HistoryBack);

        CloseTopPageOfStack();
    }

    private void CloseTopPageOfStack()
    {
        if (_stackPatternPaths.Count == 0)
        {
            return;
        }

        var current = _stackPatternPaths.Peek();
        current.Active = false;

        Task.Run(async () =>
        {
            await Task.Delay(300); // wait for the transition to complete
            _stackPatternPaths.Pop();
            _previousPath = _stackPatternPaths.LastOrDefault()?.AbsolutePath;
            _ = InvokeAsync(StateHasChanged);
        });
    }

    private StackPatternPath GetCurrentStackPatternPath()
    {
        var absolutePath = NavigationManager.GetAbsolutePath();
        var selfPatternRegex = CachedSelfPatternRegexes.FirstOrDefault(r => r.IsMatch(absolutePath));
        return selfPatternRegex is null ? new StackPatternPath(absolutePath) : new StackPatternPath(selfPatternRegex.ToString(), absolutePath);
    }

    protected override ValueTask DisposeAsyncCore()
    {
        NavigationManager.LocationChanged -= NavigationManagerOnLocationChanged;

        return base.DisposeAsyncCore();
    }

}